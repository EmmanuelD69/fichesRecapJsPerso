<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>EmmanuelDev Mémo Javascript - TABLEAUX</title>
		<link rel="stylesheet" href="../scss/basesJs.css" />
	</head>

	<body>
		<header>
			<h1 class="titre">JAVASCRIPT MEMO</h1>
		</header>
		<main>
			<section id="liste">
				<ul id="liste-p">
					<li class="article">
						<h2 class="titre-article">
							DOM / DOCUMENT OBJET MODEL
						</h2>
						<p class="paragraphe explication">
							On peut schématiser le DOM comme un arbre généalogique que l'on
							appel l'objet "window" ou l' <u>objet global</u>. <br />
							Il contient un ensemble de paramètres représentant
							les éléments contenus dans une page web <br />
							et dont l'<span>objet "document" est le point d'origine / la racine</span>.
							<br />
							Pour y accéder il suffit de taper dans la console
							"window.document" ou "document". <br />
                            <br />
                            <h2>REPRESENTATION GRAPHIQUE DU DOM</h2>
							<img src="../img/DOM.png" alt="représentation graphique du DOM" />
						</p>
					</li>
					<li class="article">
						<h2 class="titre-article"> NOTION DE CONTEXTE GLOBAL D'EXECUTION</h2>
						<p class="paragraphe explication">Avant même que l'on ai codé quoi que ce soit, Javascript crée en arrière plan un environnement global de travail. <br> Celui-çi inclut la création de l'objet global "window" ainsi que du mot clé "this" dont nous allons parler plus loin. <br> Ce procédé est aussi appelé la <u>phase de création (creation phase)</u>. <br><br>Lors de cette phase, avant même d'avoir codé une ligne de code, Javascript crée et alloue un espace mémoire dans l'objet global <br> qui permettra de mémoriser nos fonctions et variables. On peut le schématiser comme le cache mémoire <br> d'un ordinateur, ou encore le local storage de notre navigateur web. <br><br> La seconde phase après la création est <u>la phase d'exécution (execution phase)</u>. <br>Il s'agit de la phase où notre code s'exécute et où un la notion de hissage (hoisting) entre en action.
						</p>
					</li>
					<li class="article">
						<h2 class="titre-article"> NOTION DE HOISTING - HISSAGE</h2>
						<p class="paragraphe explication">
							Lorsque l'on déclare des fonctions ou/et des variables il est important de  garder à l'esprit la notion de "hoisting".<br><br>
							Qu'est ce que c'est? <br><br>
							<span>C'est la capacité à enregister dans la mémoire de l'objet global les fonctions et variables que l'on a déclaré.</span><br>
							Pour résumer, une fois déclarées dans notre fichier js, il y'a une lecture passive <br> qui va les garder en mémoire dans l'objet global. <br> elles  restent accessibles à tout moment par l'intermédiaire de la console<br> et sont visibles dans l'objet global "window". <br><br>
							Source MDN: <br> <cite>une définition stricte du hissage suggère que les déclarations de variables et de fonctions <br> sont déplacées physiquement en haut de votre code, mais ce n'est pas ce qui se passe en fait. <br> A la place, <u>les déclarations de variables et de fonctions sont mises en mémoire</u> <br> pendant la phase de compilation, mais restent exactement là où vous les avez tapées dans votre code.</cite>
						</p>
						<p class="paragraphe example">
							Soit une fonction simple "sayHi()": <br><br>
							1 - Appel de la fonction avant la déclaration <br>
							sayHi();<br><br>
							2 - Déclaration de la fonction: <br>
							function sayHi(){ <br>
								&emsp;console.log("Hello");<br>
								} <br><br>
								3 - Une lecture passive de la fonction s'effectue lorsque l'on sauvegarde (CTRL+S) <br> le fichier Javascript, ce qui entraine par la même occasion la mémorisation de la fonction. <br><br>
								4 - La console affiche le message "Hello".
						</p>
						<p class="paragraphe explication"><span>ATTENTION: LES VALEURS DES VARIABLES NE SONT PAS MEMORISEES, JUSTE LEUR DECLARATIONS</span></p>
						<p class="paragraphe example">!!!Rappel!!! <br>
							Déclaration d'une variable: <br>
							let mail;<br>
							const nom;<br><br>
							Affectation d'une valeur à la variable: <br>
							let mail = 10;<br>
							const nom = "Rick";<br><br>
							A la différence des fonctions, au moment où l'on sauve (CTRL+S) <br>seul l'information sur le nom de la variable (sa déclaration) est enregistré en mémoire. <br>
							L'objet global est conscient de son existence mais n'a pas connaissance de la valeur.  <br><br>
							Cela signifie que si l'on tente d'afficher le contenu d'une variable <br> avant que sa valeur ait été attribuée, nous obtiendrons un message d'erreur. <br><br>
							console.log(nom); <br>
							const nom = "Rick"; <br>
							Uncaught ReferenceError: Cannot access 'nom' before initialization <br><br>
							const nom = "Rick";<br>
							console.log(nom);<br>
							La console affichera bien la valeur de la variable nom, pas de message d'erreur.
						</p>
					</li>
					<li class="article">
						<p class="paragraphe example" style="color: green;">
							La suite arrive bientôt, en cours d'intégration.
						</p>
					</li>
					<li class="article"></li>
				</ul>
			</section>
		</main>
		<footer>
			<h3>&copy;EmmanuelDev 2020</h3>
		</footer>
		<script src="../js/test.js"></script>
	</body>
</html>
