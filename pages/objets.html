<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>EmmanuelDev Mémo Javascript - TABLEAUX</title>
	<link rel="stylesheet" href="../scss/basesJs.css" />
</head>

<body>
	<header>
		<h1 class="titre">JAVASCRIPT MEMO</h1>
	</header>
	<main>
		<section id="liste">
			<ul id="liste-p">
				<li class="article">
					<h2 class="titre-article">LES OBJETS</h2>
					<p class="paragraphe explication">
						Un objet est comme un livre contenant des chapitres ayant chacun
						un titre et du contenu. <br /><br />
						En version Javascript cela donne: <br />
						<span>Un objet est une donnée de type référence qui possède une ou
							plusieurs propriétés. <br />
							Une propriété est l'association d'un nom(key) et d'une
							valeur(value).</span><br /><br />
						!!! PROPERTY = KEY / VALUE !!!<br />
						Le contenu d'un objet s'écrit entre accolades <span>{}</span> et
						chaque "propriété" est séparée par une virgule.<br />
						ATTENTION: on peut stocker des fonctions dans un objet, elles sont
						alors renommées "<span>méthodes</span>".
					</p>
					<p class="paragraphe example">
						Example1: <br />
						const user = { <br />
						&emsp;name: "Jean-luc", <br />
						&emsp;age: 36, <br />
						&emsp;married: false, <br />
						&emsp;greet: function(){ /* Version longue*/ <br />
						&emsp;console.log("hello there!"); <br />
						&emsp;}, <br />
						};
					</p>
					<p class="paragraphe explication">
						On peut utiliser un raccourci pour écrire une méthode en
						supprimant ": function", cela correspond exactement à la même
						chose en version simplifié.
					</p>
					<p class="paragraphe example">
						Example2: <br />
						const user = { <br />
						&emsp;name: "Jean-luc", <br />
						&emsp;age: 36, <br />
						&emsp;married: false, <br />
						&emsp;greet(){ /* Version simplifiée */ <br />
						&emsp;console.log("hello there!"); <br />
						&emsp;}, <br />
						};
					</p>
					<p class="paragraphe explication">
						Un objet peut par exemple identifier une personne et contenir des
						informations concernant cette personne. <br />
						Un objet est composé de propriétés qui se décompose en deux temps,
						tout d'abord la clé, puis sa valeur. <br />
						Dans notre example, "name" est la clé, et "Emmanuel" est la
						valeur, l'ensemble formant la première propriété de l'objet
						"user".
					</p>
					<p class="paragraphe explication">
						pour acceder à une information dans un objet, il faut le nommer et
						ajouter un point (.) avant de nommer la propriété qui nous
						intéresse.
					</p>
					<p class="paragraphe example">
						Example: <br />
						console.log(user.name);
					</p>
					<p class="paragraphe explication">
						ou directement dans la console avec:
					</p>
					<p class="paragraphe example">
						user.name;
					</p>
				</li>
				<li class="article">
					<h2 class="titre-article">THIS - Qu'est ce que c'est?</h2>
					<p class="paragraphe explication">
						Il s'agit d'un pointeur qui cible un objet. Par default, si l'on
						fait un console.log de "this", il va cibler l'objet "window".
					</p>
					<p class="paragraphe example">
						console.log(this); <br /><br />
						Résultat: <br />
						Window {parent: Window, opener: null, top: Window, length: 0,
						frames: Window, …}
					</p>
					<p class="paragraphe explication">
						<u>"this" dans un objet:</u> <br />
						Si on utilise "this" dans une méthode(fonction) se trouvant dans
						un objet, <br />
						"this" va pointer vers l'objet qui le contient.
					</p>
					<p class="paragraphe example">
						Soit l'objet "user": <br /><br />
						const user = { <br />
						&emsp;name: "emmanueldev", <br />
						&emsp;sayHi() { <br />
						&emsp;&emsp;console.log(this);<br />
						&emsp;},<br />
						};<br /><br />
						on appel la méthode se trouvant dans l'objet "user"<br />
						user.sayHi();<br /><br />
						le résultat qui s'affichera en console est l'objet "user": <br />
						Object { name: "emmanueldev", sayHi: sayHi() }
					</p>
					<p class="paragraphe explication">
						<u>"this" dans une fonction du scope global:</u> <br />
						On peut créer une fonction dans le scope global contenant "this"
						et l'insérer dans un objet.
					</p>
					<p class="paragraphe example">
						Soit 2 objets "user" et "admin": <br />
						<span style="color: rgb(133, 133, 211);">const user = { <br />
							&emsp;name: "emmanueldev", <br />
							};</span><br /><br />
						<span style="color: greenyellow;">const admin = { <br />
							&emsp;name: "admin", <br />
							};</span><br /><br />
						On crée la fonction "sayHi()" dans le scope global:<br />
						function sayHi() { <br />
						&emsp;console.log(this); <br />
						}<br /><br />
						On ajoute une propriété à l'objet "user" qui aura pour clé "fn" et
						pour valeur "sayHi", <br />
						"sayHi" étant la fonction que nous avons crée dans le scope
						global.
						<br />
						<span style="color: rgb(133, 133, 211);">user.fn = sayHi;</span>
						<br /><br />
						Même chose avec l'objet "admin", on ajoute une propriété qui aura
						pour clé "fn" et pour valeur "sayHi", <br />
						<span style="color: greenyellow;">admin.fn = sayHi;</span>
						<br /><br />

						pour appeler la fonction dans l'objet, il suffit simplement
						d'utiliser le code suivant: <br />
						<span style="color: rgb(133, 133, 211);">user.fn();</span><br />
						<span style="color: greenyellow;">admin.fn();</span><br /><br />
						on obtiendra dans la console: <br />
						<span style="color: rgb(133, 133, 211);">Object { name: "emmanueldev", fn: sayHi() }</span>
						<br />
						<span style="color: greenyellow;">Object { name: "admin", fn: sayHi() }</span>
					</p>
					<p class="paragraphe explication">
						PAS BESOIN DE DUPLIQUER UNE FONCTION, ON LA DECLARE UNE SEULE FOIS
						<br />
						ET ON L'AJOUTE DANS LES OBJETS DE NOTRE CHOIX SANS RETAPER SON
						CODE.
					</p>
					<p class="paragraphe example">
						Example d'usage de this: <br />
						function majuscule () {<br />
						&emsp;console.log(this.name.toUpperCase());<br />
						} <br /><br />
						la fonction "majuscule()" va transformer le texte contenu dans la
						propriété "name" en majuscule. <br />
						"this" permet de cibler l'objet qui à fait appel à la fonction.
					</p>
					<p class="paragraphe explication">
						<u><span>Cas particulier</span> - "this" dans une fonction faisant
							partie d'une méthode contenue dans un objet.</u>
					</p>
					<p class="paragraphe explication">
						Vous me suivez? non? je m'explique! <br />
						Rappel: une fonction se trouvant à l'intérieur d'un objet est
						appelée une "méthode". <br />
						Et une fonction peut faire appel dans son propre scope à une autre
						fonction. Une fonction dans une fonction! <br />
						Donc, une méthode peut faire appel à une fonction dans son propre
						scope. <br />
						Vous me suivez maintenant?
					</p>
					<p class="paragraphe example">
						const user = { <br />
						name: "emmanueldev", <br />
						videos: ["html", "css", "javascript", "react"], <br />
						<span style="color: rgb(133, 133, 211);">greet(){ <br />
							&emsp;console.log(`Hello there ${this.name}`);<br />
							&emsp;//add function</span>
						<br />
						&emsp;<span style="color: greenyellow;">const getVideos = function() { <br />
							&emsp;&emsp;console.log(`You currently have
							${this.videos.length} videos`);
							<br />
							&emsp;&emsp;};</span><br />
						&emsp;<span style="color: rgb(133, 133, 211);">getVideos();<br />
							&emsp;}</span>
						<br />
						}; <br /><br />
						user.greet(); <br />
						On lance l'exécution de la méthode "greet()" faisant parti de
						l'objet "user" <br />
						ce qui induit que "this" va cibler l'objet "user". <br />
						Ce qui est vrai dans la méthode, ne l'est plus dans la fonction
						"getVideos()" <br /><br />
						la fonction getVideos étant <u>"indirectement"</u> appelée dans
						l'execution de la méthode "greet", <br />
						<span>le "this" qu'elle contient ne fais donc pas directement
							référence à l'objet qui la contient</span>, <br />
						par conséquent nous obtiendrons un message d'erreur car sans
						cibler directement un objet, <br />
						this se réfèrera par défaut à l'objet "Window". <br /><br />
						résultat dans la console: <br />
						<span style="color: rgb(133, 133, 211);">Hello there emmanueldev</span>
						<br />
						<span style="color: greenyellow;">TypeError: can't access property "length", this.videos is
							undefined</span>
					</p>
					<p class="paragraphe explication">
						Pour pallier à ce problème, il faut utiliser une
						<span><u>"fonction arrow"</u></span>.<br />
						Pour cela on retire le terme "function" et on place après les
						paranthèses "()" le symbole "<span>=></span>"<br />
						C'est actuellement une bonne pratique à utiliser qui correspond à
						la norme ES6 cela évite bien des problèmes...
					</p>

					<p class="paragraphe example">
						<span style="color: rgb(133, 133, 211);">const user = {<br />
							&emsp;name: "emmanueldev",<br />
							&emsp;videos: ["html", "css", "javascript", "react"],<br />
							&emsp;greet() {<br />
							&emsp;&emsp;console.log(`Hello there ${this.name}`);<br />
							&emsp;&emsp;//add function</span>
						<br />
						&emsp;&emsp;<span style="color: greenyellow;">const getVideos = () => { <br />
							&emsp;&emsp;&emsp;console.log(`You currently have
							${this.videos.length} videos`);<br />
							&emsp;&emsp;};</span><br />
						<span style="color: rgb(133, 133, 211);">&emsp;&emsp;getVideos();<br />
							&emsp;}, <br />
							};</span><br /><br />
						La fonction arrow est introduite avec l'écriture suivante =>.
						<br />
						<span>Une fonction arrow ne crée pas un nouveau "this", elle prolonge
							celui déjà existant</span>, <br />
						il n'y a donc pas de "reset" de this et la référence à l'objet est
						conservée. <br /><br />

						user.greet();<br /><br />
						Résultat en console: <br />
						<span style="color: rgb(133, 133, 211);">Hello there emmanueldev</span>
						<br />
						<span style="color: greenyellow;">You currently have 4 videos</span>
						<br />
					</p>
				</li>
				<li class="article">
					<h2 class="titre-article">BIND - qu'est ce que c'est?</h2>
					<p class="paragraphe explication">
						<span>"bind()"" est une méthode qui permet de lier une fonction
							située dans le scope global à un objet.</span><br /><br />
						La fonction qui aura été associée à l'objet pourra accéder à
						l'ensemble de son contenu grâce à l'usage de "this". <br /><br />
						RAPPEL: Une fonction est soit: <br />
						Déclarée dans le scope global, "this" fait référence à l'objet
						"window" <br />
						ou <br />
						Déclarée dans un objet et on l'appelle alors une "méthode", "this"
						fait référence à l'objet la contenant<br />
						ou <br />
						Déclarée au sein d'une méthode, "this" fait référence à l'objet
						"window" <u>si on n'utilise pas de fonction arrow(=>)</u>.<br />
						Si une fonction arrow (=>) est utilisée, alors "this" fera
						référence à l'objet qui contient la méthode dans laquelle la
						fonction est incluse.
					</p>
					<p class="paragraphe example">
						Example: <br />
						1-CREATION OBJET "PERSON" AVEC METHODE "<span
							style="color: rgb(133, 133, 211);">GETFULLNAME</span>" <br /><br />
						const person = { <br />
						&emsp;firstName: "emmanuel", <br />
						&emsp;lastName: "dev", <br />
						&emsp;<span style="color: rgb(133, 133, 211);">getFullName(){ <br />
							&emsp;&emsp;console.log(`hello my name is ${this.firstName} ${this.lastName}`); <br />
							&emsp;},</span>
						<br />
						};<br /><br />
						2-CREATION FONCTION "<span style="color: greenyellow;">REGISTERUSER</span>" DANS LE SCOPE GLOBAL
						<br />
						Au moment de la déclaration de la fonction, this n'est pas lié à
						l'objet "person". <br /><br />

						<span style="color: greenyellow;">function registerUser() {<br />
							//fonctionnalitées additionnelles.... <br />
							console.log(this);<br />
							this.getFullName(); <br />
							}</span>
						<br /><br />
						3-CREATION D'UNE CONSTANTE REGISTER CONTENANT LA FONCTION
						"REGISTERUSER" QU'ON LIE A L'OBJET "PERSON" <br /><br />
						const register =
						<span style="color: greenyellow;">registerUser</span>.<span>bind(person)</span>; <br /> <br>
						La fonction registerUser est liée à l'objet "person" en utilisant
						".bind()", dont "person" est l'argument. <br /><br>
						si l'on fait un console.log(register) on obtient:<br />
						function registerUser() | <u>on a donc sauvegardé une fonction dans la variable register</u><br>
						name: "bound registerUser" | <u>"indique bien que la fonction est lié"</u><br><br>
						4-EXECUTION DE LA FONCTION CONTENUE DANS LA VARIABLE REGISTER:
						<br />
						register(); <br />
						Comme la variable "register" contient une fonction on peut l'exécuter en ajoutant les
						paranthèses "()"
						après son nom<br>
						comme l'on executerai une fonction.<br><br>
						Résultat en console: <br>
						Object { firstName: "emmanuel", lastName: "dev", getFullName: getFullName() } <br>
						Hello there emmanuel dev <br><br>
						bind() a permis à la fonction "registerUser" de se connecter à l'objet "person" <br> et ainsi de
						pouvoir accéder à ses
						propriétés.

					</p>
				</li>
				<li class="article">
					<h2 class="titre-article">CALL - qu'est ce que c'est?</h2>
					<p class="paragraphe explication">C'est exactement la même chose que BIND, à la différence que la
						fonction n'est pas
						sauvegardée <br> dans une variable mais lance un appel direct vers l'objet
						auquel elle a été liée. <br><br>
						Pour les paramètres, on passe en premier le nom de l'objet auquel on souhaite lier la fonction,
						<br>
						et ensuite d'autres arguments, si nécéssaire, en fonction de ce dont la fonction à besoin.</p>
					<p class="paragraphe example">
						<span style="color: rgb(133, 133, 211);">const person</span> = { <br />
						&emsp;firstName: "emmanuel", <br />
						&emsp;lastName: "dev", <br />
						&emsp;getFullName(){ <br />
						&emsp;&emsp;console.log(`hello my name is ${this.firstName} ${this.lastName}`); <br />
						&emsp;},
						<br />
						};<br /><br />
						<span style="color: greenyellow;">function registerUser</span>(country, lang, methode) {<br />
						&emsp;//fonctionnalitées additionnelles.... <br />
						&emsp;console.log(this);<br />
						&emsp;this.getFullName(); <br />
						&emsp;&emsp;console.log(`My country is ${country} and my language is ${lang} and i used
						méthod
						${methode}`
						);<br>
						}
						<br /><br />
						<span style="color: greenyellow;">registerUser</span>.call(<span
							style="color: rgb(133, 133, 211);">person</span>, 'France', 'Fr', 'CALL');
					</p>
				</li>
				<li class="article">
					<h2 class="titre-article">APPLY - qu'est ce que c'est?</h2>
					<p class="paragraphe explication">C'est le même cas de figure que CALL, la seule chose qui varie est
						le moyen utilisé pour déclarer les paramètres de la fonction.
						Au lieu d'utiliser directement des strings(<span>"..",".."</span>),
						on utilise un tableau de strings(<span>["..",".."]</span>).
					</p>
					<p class="paragraphe example">
						<span style="color: rgb(133, 133, 211);">const person</span> = { <br />
						&emsp;firstName: "emmanuel", <br />
						&emsp;lastName: "dev", <br />
						&emsp;getFullName(){ <br />
						&emsp;&emsp;console.log(`hello my name is ${this.firstName} ${this.lastName}`); <br />
						&emsp;},
						<br />
						};<br /><br />
						<span style="color: greenyellow;">function registerUser</span>(country, lang, methode) {<br />
						&emsp;//fonctionnalitées additionnelles.... <br />
						&emsp;console.log(this);<br />
						&emsp;this.getFullName(); <br />
						&emsp;&emsp;console.log(`My country is ${country} and my language is ${lang} and i used
						méthod
						${methode}`
						);<br>
						}
						<br /><br />
						<span style="color: greenyellow;">registerUser</span>.apply(<span
							style="color: rgb(133, 133, 211);">person</span>,
						<span>['France', 'Fr', 'CALL']</span>);
					</p>
				</li>
				<li class="article">
					<h2 class="titre-article">CONSTRUCTOR FUNCTION - Qu'est ce que c'est?</h2>
					<p class="paragraphe explication">
						<span>C'est une "fonction" qui va générer des "objets".</span> <br>
						C'est un moyen façile de créer autant d'objets que l'on souhaite. <br>
						<u>De manière général, pour identifier une fonction constructor, on va écrire son nom en
							UPPERCASE</u><br>
						Chaque nouvel objet est créé en utilisant le mot clé "new". <br>Si le terme "new" est présent,
						c'est qu'on à une fonction constructor à l'oeuvre. <br><br>
						Chaque objet est unique, et toutes les propriétés qu'il contient lui sont unique, même si ces
						<br>
						propriétés ont exactement les mêmes déclarations de keys/ values que les propriétés d'un autre
						objet.
						<br><br>
						<u>EXEMPLE: Fonction constructor pour créer des objets "user"</u>
					<p class="paragraphe example">
						Soit une fonction constructor USER avec laquelle je souhaite créer des objets simples comprenant
						3 propriétés: <br>
						-une pour le nom, <br>
						-une autre pour le prénom, <br>
						et une troisième pour afficher en
						console le nom et le prénom. <br><br>
						function USER(<span style="color: rgb(133, 133, 211);">name</span>, <span
							style="color: greenyellow;">surname</span>) { <br>
						&emsp;this.name = <span style="color: rgb(133, 133, 211);">name</span>; <br>
						&emsp;this.surname = <span style="color: greenyellow;">surname</span>; <br>
						&emsp;this.<span style="color: orange;">getName</span> = function () { <br>
						&emsp;&emsp;console.log(`${this.name} ${this.surname}`); <br>
						&emsp;};<br>
						} <br><br>
						"<span style="color: orange;">getName</span>" est une méthode qui sera créée à l'identique dans
						tous les objets issus de cette fonction constructor, ce qui aura pour effet de créer une copie
						de la méthode à chaque nouvel objet. <br>
						Ce qui deviendra rapidement problématique si l'on crée trop de copies(voir article "Prototype
						- qu'est ce que c'est?"). <br><br>
						const user1 = new USER(<span style="color: rgb(133, 133, 211);">"Emmanuel"</span>, <span
							style="color: greenyellow;">"Dev"</span>);<br>
						const user2 = new USER(<span style="color: rgb(133, 133, 211);">"Laurent"</span>, <span
							style="color: greenyellow;">"Leblanc"</span>);<br><br>
						<span>new user() crée un nouvel objet et utilise les arguments entre paranthèses <br> pour
							completer
							les
							propriétées de l'objet nouvellement créé.</span><br><br>
						Résultats en console: <br>
						console.log(user1);<br>
						Object { name: "Emmanuel", surname: "Dev", getName: getName() } <br><br>
						console.log(user2);<br>
						Object { name: "Laurent", surname: "Leblanc", getName: getName() }


					</p>
					</p>
				</li>
				<li class="article">
					<h2 class="titre-article">PROTOTYPE - Qu'est ce que c'est?</h2>
					<p class="paragraphe explication">
						C'est une propriété présente dans tous les objets existants, c'est en quelques sorte une
						propriété par default. <br>
						Il faut l'imaginer comme une boite à outils, dont chaque objet dispose. <br>
						A l'intérieur de cette boite à outils, on peut y ranger des "méthodes"(outils) qui seront
						disponibles pour l'ensemble des objets issus de la même fonction constructor. <br>
						On peut remplir/vider cette boite à outils avec de nouvelles méthodes(outils), qui ne seront pas
						une copie de méthodes déjà existantes, mais bien un original unique. <br>
						A la différence d'une méthode qui serait créer dans une fonction constructor et copié à chaque
						création d'objet, ce qui finirai par saturer l'espace de stockage de l'objet global. <br><br>
						!!! BONNE PRATIQUE: EVITER D'ASSOCIER DES METHODES A UNE FONCTION CONSTRUCTOR MAIS LES AJOUTER
						AU PROTOTYPE DE LA FONCTION CONSTRUCTOR POUR EVITER DE LES DUPLIQUER !!! <br><br>
						<span>Toutes les données primitives sont créées à partir de fonctions constructor</span>,<br>
						c'est pour cela qu'on peut leur appliquer des méthodes, car ces méthodes sont stockées dans la
						propriété prototype de la
						fonction constructor qui les a créées.
					</p>
					<p class="paragraphe example">
						Example: <br>
						const name = "emmanueldev"; <br> Ceci est une donnée primitive de type string telle que nous la
						déclarons. <br><br>
						const objName = new String("emmanueldev"); <br>
						Ceci est la même donnée primitive sous sa forme
						originelle, sa véritable forme avant d'être convertie. <br>
						C'est une conversion automatique qui nous est invisible mais qui apporte avec elle la propriété
						"prototype" <br> contenant des méthodes utilisables par defaut sur notre donnée primitive.
						<br><br>
						Si on fait un console log de "objName": <br>
						String { "emmanueldev" }​ <br>
						0: "e"​<br>
						1: "m"​<br>
						2: "m"​<br>
						3: "a"​<br>
						4: "n"​<br>
						5: "u"​<br>
						6: "e"​<br>
						7: "l"​<br>
						8: "d"​<br>
						9: "e"​<br>
						10: "v"​<br>
						length: 11​<br>
						prototype: String { "" } <br><br>
						Je vous invite à faire un essai et vous constaterez par vous même ce que la propriété prototype
						contient. <br>
						On a objet représentant une donnée primitive de type string avec une propriété prototype qui
						contient tout un ensemble de méthodes que l'on peut appliquer à une string. <br><br>
						Ce qui se passe lorsque qu'on applique une méthode à une donnée primitive comme une string,
						c'est que la string est temporairement introduite dans un objet de sorte à lui appliquer la
						méthode souhaité se trouvant dans la propriété prototype, puis une fois cette action effectuée,
						on ressort la string modifié pour lui redonner son status de "string" et non plus d'objet
						string. <br><br>
						Example: <br>
						const name = "emmanueldev"; <br>
						const upper = name.toUpperCase(); <br>
						console.log(typeof upper); <br> le console log affichera un string. <br><br>
						RESUME: <br>
						Object,<br>
						String,<br>
						Number,<br>
						Array,<br>
						Tous sont le résultat de fonctions constructor utilisées pour créer nos données. <br>On ne s'en
						rend pas compte, mais à chaque création de donnée,
						il y'a une fonction constructor qui est derrière et qui transmet la propriété "prototype" avec
						les méthodes correspondant à la donnée créée. <br>
						Ainsi on pourra appliquer à un objet certaines méthodes et à un string d'autres méthodes qui
						leurs sont propre. <br>
						Chaque nouvelle donnée "hérite" de la propriété
						"prototype" contenant les méthodes spécifiques à la donnée que l'on vient de créer. <br>
					<p class="paragraphe explication"><u>Création d'une méthode que l'on ajoute à la propriété
							"prototype"</u></p>
					<p class="paragraphe example">
						1- création de la fonction constructor USER: <br>
						function USER(<span style="color: rgb(133, 133, 211);">name</span>, <span
							style="color: greenyellow;">surname</span>) { <br>
						&emsp;this.name = <span style="color: rgb(133, 133, 211);">name</span>; <br>
						&emsp;this.surname = <span style="color: greenyellow;">surname</span>; <br>
						} <br><br>
						2- création de la méthode getName et ajout à la propriété "prototype" de la fonction constructor USER: <br>
						USER.prototype.getName = function () { <br>
						console.log(`${this.name} ${this.surname}`);<br>
						};<br><br>
						3- création d'un nouvel objet en utilisant la fonction contructor USER: <br>
						const newUser1 = new USER("Emmanuel", "Dev"); <br><br>
						4- affichons le résultat de notre travail: <br>
						console.log(typeof newUser1);<br>
						"object" <br><br>
						newUser1.getName(); <br>
						Emmanuel Dev <br><br>
						console.log(newUser1); <br>
						USER {name: "Emmanuel", surname: "Dev"} <br>
						On constate la présence des propriétés name et surname avec leurs valeurs, tandis que la méthode getName n'apparait nulle part car elle se trouve dans la propriété prototype qui est présente par défaut mais "invisible" dans le compte des propriétés des objets.. <br><br>				
						prototype: Object { getName: getName(), … } <br>
						On constate que la fonction getName à bien été ajoutée à la propriété par défaut (boite à outils) prototype. <br><br>
						console.log(Object.keys(newUser1).length);<br>
						2 <br>
						Et on a bien 2 éléments dans l'objet, pas 3! <br>Magique :) <br>
						Cela veux dire qu'à chaque fois que l'on crée un nouvel objet avec la fonction constructor USER, la méthode getName est associée à tous les objets dont USER est à l'origine.
					</p>
					</p>
				</li>
				<li class="article">
					<h2 class="titre-article">PROTOTYPAL INHERITENCE - HERITAGE DE PROTOTYPES</h2>
					<p class="paragraphe explication">
						Qu'est ce que c'est???<br>
						<span>Cela consiste à passer la propriété "prototype" d'une objet vers la propriété "prototype" d'un autre objet en lui faisant bénéficier de toutes les méthodes contenues dans le prototype du 1er objet.</span><br><br>
						C'est donc le fait de "<u>faire hériter</u>" un objet du prototype d'un autre objet tout en rendant l'ensemble des méthodes des 2 objets disponibles au nouvel objet. <br>
						On va se retrouver avec une chaine de prototypes en cascade.
					</p>
					<p class="paragraphe example">
						Prenons pour exemple un jeu de combat, je souhaite créer des monstres avec des points de vie, un nom, et un niveau. <br>
						Pour cela je vais créer une fonction constructor que j'appelerai "Enemy": <br>
						function ENEMY(life, name, level) { <br>
							&emsp;this.life = life; <br>
							&emsp;this.name = name; <br>
							&emsp;this.level = level; <br>
						} <br><br>
						En plus de cela, je souhaite créer quelques méthodes qui seront utilisées pour tous les monstres et que je vais glisser dans la propriété prototype pour ne pas avoir une multitude de copies des méthodes avec tous les monstres que je vais créer. <br><br>
						méthodes liées à la propriété prototype de la fonction constructor Enemy: <br>
						1- getInfos pour obtenir toutes les infos sur le monstre(PVs, nom, Lvl). <br>
						Enemy.prototype.getInfos = function () { <br>
							&emsp;console.log(this.life, this.name, this.level);<br>
						}; <br><br>
						2- attack pour passer l'info lorsque le monstre attaque. <br>
						Enemy.prototype.attack = function () { <br>
							&emsp;console.log(`${this.name} has attacked!`); <br>
						}; <br><br>
						3- block pour passer l'info lorsque le monstre bloque une attaque. <br>
						Enemy.prototype.block = function () { <br>
							&emsp;console.log(`${this.name} has blocked!`); <br>
						}; <br><br>
						Maintenant il y'a certains boss de fin que je souhaite rendre unique en leurs associant d'autres attributs comme par example une couleur et un sort magique. <br>
						Je me retrouve donc avec plus d'attributs que l'enemy de base, et pour ne pas avoir à reconstruire dans sa totalité la fonction constructor pour le dragon, je vais lier celle déja existante (Enemy) et simplement ajouter 2 paramètres supplémentaires. <br><br>
						function Dragon(life, name, level, color, spell) { <br>
							&emsp;Enemy.call(<span>this</span>, life, name, level); <br>
							&emsp;this.color = color; <br>
							&emsp;this.spell = spell; <br>
						} <br><br>
						Le mot clé "<span>this</span>" va cibler à l'objet "Dragon" nouvellement crée et ainsi lui attribuer toutes les propriétés nécéssaires en utilisant à la fois les paramètres de la fonction constructor Dragon et ceux de la fonction constructor Enemy grace à l'utilisation de la méthode "call". <br><br>
						<u>On n'aura pas besoin de redéclarer les propriétées "life, name, level". On va hériter de celles ci en liant la fonction constructor "Enemy" à notre objet "Dragon".</u> <br><br>
						Les dernières propriétés "color, spell" qui sont unique à l'objet "dragon" seront déclarées normalement. 
					</p>

				</li>
				<!-- <li class="article">
					<h2 class="titre-article">THIS - Qu'est ce que c'est?</h2>
				</li> -->
				<li class="article">
					<p class="paragraphe example" style="color: green;">
						La suite arrive bientôt, en cours d'intégration.
					</p>
				</li>
				<li class="article"></li>
			</ul>
		</section>
	</main>
	<footer>
		<h3>&copy;EmmanuelDev 2020</h3>
	</footer>
	<script src="../js/objet.js"></script>
</body>

</html>